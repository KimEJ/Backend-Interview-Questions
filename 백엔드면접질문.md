# 프로세스(Process)란 무엇인가요?

프로세스는 **컴퓨터에서 실행 중인 프로그램**을 의미합니다. 실행 중인 **프로그램은 메모리에 올라가서 CPU에 의해 실행**되며, 이러한 **실행 중인 프로그램을 프로세스**라고 부릅니다. 프로세스는 운영체제(
OS)에 의해 관리되며,
프로세스마다 자신의 주소 공간, 메모리, 입출력, 파일 등의 자원을 가지고 있습니다. 또한, 하나의 프로그램이 여러 개의 프로세스로 분리되어 실행될 수도 있습니다.

# 쓰레드(Thread)란 무엇인가요?

쓰레드는 **프로세스 내에서 실행되는 작업의 단위**입니다. 쓰레드는 **프로세스 내에서 자원을 공유**하면서 동시에 실행될 수 있습니다. 하나의 프로세스에서 여러 개의 쓰레드를 생성하고 관리할 수 있으며, 각각의
쓰레드는
독립적으로 실행될 수 있습니다. 쓰레드는 하나의 프로세스 내에서 작업을 분리하여 병렬적으로 실행함으로써 시스템의 성능을 향상시킬 수 있습니다.

# 멀티쓰레드(Multi-thread)와 멀티프로세스(Multi-process)의 차이점은 무엇인가요?

멀티쓰레드와 멀티프로세스는 둘 다 동시에 여러 작업을 수행하기 위한 방법이지만, 그 구현과 동작 방식에서 차이가 있습니다.

1. 개념:
    - 멀티쓰레드: 하나의 프로세스 내에서 여러 쓰레드가 동시에 실행되는 것을 의미합니다. 쓰레드는 프로세스 내에서 메모리 공간을 공유하며, 자원 접근이 간단하고 빠릅니다.
    - 멀티프로세스: 여러 개의 독립적인 프로세스가 동시에 실행되는 것을 의미합니다. 각 프로세스는 독립된 메모리 공간을 가지며, 자원 접근이 복잡하고 상대적으로 느립니다.

2. 자원 공유:
    - 멀티쓰레드: 쓰레드는 프로세스 내의 자원(메모리, 파일 등)을 공유하기 때문에, 쓰레드 간의 데이터 공유가 쉽고 빠릅니다. 하지만 이로 인해 동기화와 관련된 문제가 발생할 수 있습니다.
    - 멀티프로세스: 프로세스는 독립된 메모리 공간을 가지고 있기 때문에, 각 프로세스는 자원을 공유하기 위해 별도의 통신 매커니즘이 필요합니다. 자원 공유가 더욱 안전하지만, 프로세스 간의 통신 비용이 발생할
      수 있습니다.

3. 성능:
    - 멀티쓰레드: 쓰레드는 프로세스 내에서 메모리를 공유하고 컨텍스트 스위칭 비용이 낮기 때문에, 작업 간의 전환 및 데이터 공유가 빠릅니다. 하지만 동기화 문제로 인해 예기치 않은 결과가 발생할 수 있습니다.
    - 멀티프로세스: 프로세스는 독립된 메모리 공간을 가지고 있으며, 각각의 프로세스는 안전하게 독립적으로 실행될 수 있습니다. 하지만 프로세스 간의 통신 및 컨텍스트 스위칭 비용이 높아 성능상의 오버헤드가
      발생할 수 있습니다.

4. 안정성:
    - 멀티쓰레드: 쓰레드는 같은 프로세스 내에서 실행되므로, 메모리 공간을 공유하여 데이터의 일관성을 유지하기 어렵게 만들 수 있습니다. 동기화와 관련된 문제를 제대로 처리하지 않으면 예기치 않은 버그가 발생할
      수 있습니다.
    - 멀티프로세스: 프로세스는 독립된 메모리 공간을 가지고 있으므로, 각각의 프로세스는 안전하게 독립적으로 실행될 수 있습니다. 하지만 프로세스 간의 통신 및 동기화 문제를 고려해야 합니다.

멀티쓰레드와 멀티프로세스는 각각의 장단점을 가지고 있으며, 사용하는 상황에 따라 적절한 방식을 선택해야 합니다. 멀티쓰레드는 작업 간의 소통이 많고 자원 공유가 필요한 경우에 유용하며, 멀티프로세스는 독립성과
안정성이 중요한 경우에 적합합니다.

# 컨텍스트 스위칭이란 무엇인가요?

컨텍스트 스위칭(Context Switching)은 CPU가 현재 실행 중인 프로세스 또는 쓰레드와 다음 실행할 프로세스 또는 쓰레드 간에 실행 상태를 전환하는 작업을 말합니다. 하나의 프로세스나 쓰레드가 실행 중인
동안 다른 프로세스나 쓰레드가 실행되어야 할 때, 현재 실행 중인 작업의 상태를 저장하고 다음 작업의 상태를 로드하여 전환하는 과정입니다.

# 동기화와 동기화 기법에 대해서 설명해주세요.

동기화(Synchronization)는 병행성(Concurrency) 환경에서 여러 개의 프로세스 또는 쓰레드가 상호작용하고 공유 자원에 접근할 때, 실행 순서와 데이터 일관성을 조절하여 상호간의 조화를 이루도록
하는 메커니즘입니다. 동시에 여러 작업이 실행되는 환경에서의 데이터 일관성과 상호작용의 정확성을 보장하기 위해 필요합니다.

동기화 기법은 동기화를 구현하기 위해 사용되는 방법이며, 다양한 상황과 요구에 따라 다양한 기법들이 있습니다. 주요한 동기화 기법으로는 락(Lock), 뮤텍스(Mutex), 세마포어(Semaphore), 조건 변수(
Condition Variable) 등이 있습니다.

1. 락(Lock)과 뮤텍스(Mutex):
    - 락은 공유 자원에 대한 상호 배제를 위해 사용되는 동기화 기법입니다. 락은 공유 자원에 대한 잠금과 해제를 통해 한 번에 하나의 작업만이 공유 자원에 접근할 수 있도록 합니다. 동시에 접근하려는 작업들은
      락을 획득하기 위해 경합하고, 락을 획득한 작업만이 공유 자원에 접근할 수 있습니다. 다른 작업들은 락을 얻을 때까지 대기하게 됩니다.
    - 뮤텍스는 락의 특수한 형태로서, 상호 배제를 위한 동기화 기법입니다. 락과 마찬가지로 공유 자원에 대한 잠금과 해제를 통해 접근을 제어하지만, 뮤텍스는 락을 소유한 쓰레드만이 해당 뮤텍스를 해제할 수
      있습니다.

2. 세마포어(Semaphore):
    - 세마포어는 상호 배제와 순서 보장을 위한 동기화 기법입니다. 정수 변수로서 초기값을 가지며, 접근 가능한 개수를 나타냅니다. 세마포어는 원자적인 P (Wait)와 V (Signal) 연산을 제공합니다. P
      연산은 세마포어 값을 1 감소시키고, 값이 음수가 되면 작업이 대기하게 됩니다. V 연산은 세마포어 값을 1 증가시키고, 대기 중인 작업이 있다면 하나를 깨우게 됩니다.

3. 조건 변수(Condition Variable):
    - 조건 변수는 작업들 사이에서 특정 조건을 기다리거나 통지하기 위한 동기화 기법입니다. 조건 변수는 대기(wait)와 통지(signal) 연산을 제공합니다. 대기 연산은 조건이 만족되지 않으면 작업을 대기하도록 하고, 통지 연산은
조건을 만족시키는 작업을 깨웁니다.

동기화 기법을 사용하여 공유 자원에 대한 상호 배제와 실행 순서를 조절함으로써, 여러 작업들이 조화롭게 실행되고 데이터의 일관성과 상호작용의 정확성을 보장할 수 있습니다. 적절한 동기화 기법을 선택하여 병행성 문제를
처리할 수 있도록 해야 합니다.

# RESTful API란 무엇인가요?

RESTful API는 Representational State Transfer(표현 상태 전이)를 따르는 API입니다. **RESTful API는 HTTP 프로토콜을 이용하여, 자원을 이름으로 구분하여** 해당
자원의
상태를 주고받는 웹 서비스를 제공합니다. RESTful API는 HTTP 메서드(GET, POST, PUT, DELETE 등)를 이용하여 자원을 조작하며, JSON, XML 등의 데이터 포맷을 이용하여 데이터를
주고받습니다.

**RESTful API의 특징은 다음과 같습니다.**

* 자원(Resource)을 이름으로 구분하여 조작
* HTTP 메서드(GET, POST, PUT, DELETE 등)를 이용하여 자원 조작
* Stateless(무상태)한 통신 방식
* URI(Uniform Resource Identifier)를 통해 자원을 표현
* JSON, XML 등의 데이터 포맷을 이용하여 데이터를 주고받음

RESTful API는 간결하고 직관적인 API 설계가 가능하며, 다양한 클라이언트(웹, 모바일 등)에서 쉽게 사용될 수 있습니다. 또한, HTTP의 기본적인 기능을 이용하므로 서비스의 확장성과 재사용성이 높습니다.

# 쿠키(Cookie)와 세션(Session)의 차이점은 무엇인가요?

쿠키(Cookie)와 세션(Session)은 웹 **브라우저에서 사용되는 개념**으로, **사용자의 상태 정보를 유지하기 위해 사용**됩니다. 하지만, 쿠키와 세션은 서로 다른 방식으로 정보를 저장하고 처리합니다.

쿠키는 클라이언트(웹 브라우저)에 저장되는 작은 텍스트 파일로, 웹 사이트 방문 기록, 사용자의 로그인 정보, 쇼핑 카트 내용 등을 저장할 수 있습니다. 쿠키는 사용자가 웹 사이트에 접속할 때, 서버에서 클라이언트로
전송됩니다. 그리고, 이후 웹 사이트 방문 시, 클라이언트에서 서버로 쿠키가 전송됩니다. 이를 통해, 클라이언트와 서버 간의 상태 정보를 유지할 수 있습니다.

세션은 **클라이언트가 서버에 접속할 때, 서버에서 생성되는 고유한 정보**입니다. 세션은 일반적으로 쿠키를 이용하여 클라이언트에게 고유한 ID를 부여하고, 이 ID를 서버에서 관리합니다. 이를 통해, 클라이언트와
서버
간의 상태 정보를 유지할 수 있습니다. **세션은 보안성이 높고, 서버에서 관리하기 때문에 쿠키보다 안전**합니다.

**쿠키와 세션의 차이점은 다음과 같습니다.**

* 저장 위치: 쿠키는 클라이언트에 저장되고, 세션은 서버에 저장됩니다.
* 정보 유지 시간: 쿠키는 만료 기간이 설정되며, 세션은 클라이언트가 로그아웃하거나 브라우저를 종료할 때까지 유지됩니다.
* 보안성: 세션은 서버에서 관리되므로 보안성이 높습니다. 반면, 쿠키는 클라이언트에 저장되므로 상대적으로 보안성이 낮습니다.
* 저장 용량: 쿠키는 저장 용량이 제한되며, 세션은 서버의 용량에 따라 제한됩니다.

쿠키와 세션은 모두 **상태 정보를 유지하기 위해 사용**되며, 상황에 따라 적절한 방식을 선택하여 사용할 필요가 있습니다.

# 인증(Authentication)과 인가(Authorization)의 차이점은 무엇인가요?

인증(Authentication)과 인가(Authorization)는 웹 시스템에서 보안과 관련된 개념으로, 사용자의 접근을 제어하는 데 사용됩니다. 두 개념은 유사하게 보일 수 있지만, 목적과 처리 방식에
차이가 있습니다.

**인증은 사용자의 신원을 확인하는 과정**입니다. 인증은 보통 사용자의 ID와 비밀번호를 확인하여, 해당 사용자가 누구인지 확인하는 과정을 의미합니다. 인증 과정을 거친 후에는, 시스템에서 사용자의 신원을
인정하고, 해당
사용자가 시스템에 접근할 수 있도록 합니다.

반면, **인가는 인증된 사용자가 시스템 내의 리소스에 접근할 때, 어떤 작업을 수행할 수 있는지를 결정하는 과정**입니다. 권한 부여는 보통 사용자의 역할(Role)이나 그룹(Group) 등의 정보를 확인하여,
해당
사용자가 수행할 수 있는 작업을 결정합니다. 예를 들어, 관리자 권한을 가진 사용자는 시스템의 모든 리소스에 접근할 수 있지만, 일반 사용자는 제한된 리소스에만 접근할 수 있습니다.

요약하면, 인증은 사용자의 신원을 확인하고, 인가는 인증된 사용자가 수행할 수 있는 작업을 결정하는 과정입니다. 인증과 권한 부여는 웹 시스템에서 보안을 유지하고, 안전한 접근을 보장하는 데 중요한 역할을
합니다.

# 자주 사용되는 HTTP ERROR CODE에 대해서 아시는 대로 말씀해주세요.

- **200 OK: 요청이 성공적으로 처리되었다는 것을 나타냅니다.**
- **201 Created: 새로운 자원이 성공적으로 생성되었다는 것을 나타냅니다.**
- **204 No Content: 요청이 성공적으로 처리되었으며, 서버가 응답할 콘텐츠가 없음을 나타냅니다.**
- 301 Moved Permanently: 요청한 자원이 새로운 URL로 이동되었다는 것을 나타냅니다.
- 302 Found: 요청한 자원이 일시적으로 다른 URL로 이동되었다는 것을 나타냅니다.
- **400 Bad Request: 클라이언트의 요청이 잘못되었다는 것을 나타냅니다.**
- **401 Unauthorized: 요청한 자원에 대한 인증이 필요하다는 것을 나타냅니다.**
- **403 Forbidden: 요청한 자원에 대한 접근 권한이 없다는 것을 나타냅니다.**
- 404 Not Found: 요청한 자원을 서버에서 찾을 수 없다는 것을 나타냅니다.
- **500 Internal Server Error: 서버 내부에서 오류가 발생했다는 것을 나타냅니다.**
- 501 Not Implemented: 요청한 메소드가 서버에서 지원되지 않는다는 것을 나타냅니다.
- 502 Bad Gateway: 게이트웨이 또는 프록시 서버에서 오류가 발생했다는 것을 나타냅니다.
- 503 Service Unavailable: 서버가 일시적으로 요청을 처리할 수 없다는 것을 나타냅니다.
- 504 Gateway Timeout: 게이트웨이 또는 프록시 서버에서 요청 시간 초과가 발생했다는 것을 나타냅니다.

# CI/CD(Continuous Integration/Continuous Deployment)란 무엇인가요?

CI/CD(Continuous Integration/Continuous Deployment)는 소프트웨어 개발 방법론 중 하나로, 소프트웨어 개발과 배포를 지속적으로 자동화하는 방식입니다.

CI/CD는 다음과 같은 단계로 이루어집니다.

1. Continuous Integration: 개발자가 작성한 코드를 지속적으로 빌드하고, 테스트하는 단계입니다. 이를 통해 코드의 품질을 높이고, 버그를 빠르게 찾아 수정할 수 있습니다.

2. Continuous Delivery: 빌드된 코드를 지속적으로 **배포 가능한 상태로 유지**하는 단계입니다. 이를 통해, 언제든지 새로운 버전을 **배포할 수 있는 준비 상태를 유지**합니다.

3. Continuous Deployment: Continuous Delivery 단계에서 검증된 코드를 **실제 서비스에 자동으로 배포하는 단계**입니다.

CI/CD는 소프트웨어 개발 프로세스를 자동화하고, 지속적으로 개발과 배포를 수행함으로써, 개발자와 운영팀 사이의 협업을 강화하고, 효율성을 높이는 데 큰 도움을 줍니다. CI/CD를 적용하면, 개발자는 변경 사항을
자주 통합하고, 빠른 피드백을 받을 수 있으며, 배포도 자동화되므로, 개발과 배포의 시간과 비용을 절감할 수 있습니다.

# SQL JOIN의 종류에 대해서 설명해주세요.

* **INNER JOIN**

두 개 이상의 테이블에서 조건에 맞는 레코드만을 반환합니다.
일치하는 레코드가 없으면 반환하지 않습니다.

* **LEFT JOIN**

왼쪽 테이블의 모든 레코드를 반환하고, 오른쪽 테이블과 조건에 맞는 레코드가 있으면 함께 반환합니다.
조건에 맞는 레코드가 없으면 NULL 값을 반환합니다.

* RIGHT JOIN

오른쪽 테이블의 모든 레코드를 반환하고, 왼쪽 테이블과 조건에 맞는 레코드가 있으면 함께 반환합니다.
조건에 맞는 레코드가 없으면 NULL 값을 반환합니다.

* FULL OUTER JOIN

왼쪽과 오른쪽 테이블 모두에서 조건에 맞는 레코드를 반환합니다.
조건에 맞는 레코드가 없는 경우 NULL 값을 반환합니다.

* CROSS JOIN

두 개 이상의 테이블에서 모든 가능한 조합을 반환합니다.
레코드 수가 많은 경우 결과가 매우 크게 나올 수 있으므로 사용할 때 주의가 필요합니다.

* SELF JOIN

같은 테이블을 여러 번 참조해서 조인합니다.
이를 통해 하나의 테이블에서도 다양한 정보를 추출할 수 있습니다.

# SQL과 NoSQL의 차이점은 무엇인가요?

SQL은 Structured Query Language의 약자로, 관계형 데이터베이스(RDBMS)에서 사용되는 데이터베이스 언어입니다. SQL은 **데이터를 테이블 형태로 저장하고, 테이블 간의 관계를 이용**하여
데이터를
검색하고 조작합니다.

NoSQL은 Not Only SQL의 약자로, 관계형 데이터베이스 이외의 다양한 형태의 데이터를 저장하고 처리할 수 있는 데이터베이스입니다. NoSQL은 **스키마가 없거나 유연한 스키마를 제공하며, 대량의 비정형
데이터 처리에 효과적**입니다.

SQL과 NoSQL의 주요 차이점은 다음과 같습니다.

* 데이터 모델: **SQL은 테이블** 형태의 데이터 모델을 사용하며, **NoSQL은 키-값, 문서, 그래프 등 다양한 데이터 모델**을 사용합니다.
* 스키마: SQL은 **정해진 스키마**를 가지며, 데이터 입력 전에 스키마가 먼저 정의되어야 합니다. 반면에, NoSQL은 **유연한 스키마**를 가지며, 데이터 입력 시 스키마가 동적으로 생성될 수 있습니다.
* 확장성: SQL은 **수평적 확장이 어렵고, 수직적 확장만 가능**합니다. 반면에, NoSQL은 **수평적 확장이 가능하며, 대용량 데이터 처리에 효과적**입니다.

# 데이터베이스(Database) 정규화(Normalization)란 무엇인가요?

데이터베이스 정규화는 **데이터의 중복을 제거하고, 데이터의 일관성과 무결성을 유지하기 위한 과정**입니다. 데이터베이스 **정규화는 주로 관계형 데이터베이스에서 사용**되며, 다양한 정규화 단계를 거쳐 데이터를
최적화합니다.

데이터베이스 정규화는 대체로 다음과 같은 절차를 따릅니다.

* 제1정규화: 데이터 중복을 제거하기 위해, 모든 속성이 원자적인 값만 가지도록 테이블을 분리합니다.
* 제2정규화: 제1정규화가 완료된 테이블에서, 부분적 종속성(Partial Dependency)을 제거합니다. 이를 위해, 테이블을 분리하고 외래키를 추가합니다.
* 제3정규화: 제2정규화가 완료된 테이블에서, 이행적 종속성(Transitive Dependency)을 제거합니다. 이를 위해, 테이블을 분리합니다.

데이터베스 정규화는 제4정규화, 제5정규화 등의 단계가 추가적으로 있습니다. 이 단계들은 더욱 복잡한 데이터 구조에서 필요하며, 데이터베이스 구조가 복잡해질수록 적용해야 하는 정규화 단계가 많아집니다.

정규화를 통해 데이터 중복을 제거하고, 데이터의 일관성과 무결성을 유지할 수 있습니다. 그러나, **정규화를 지나치게 진행할 경우 데이터베이스의 성능이 저하될 수 있으므로,** 적절한 수준의 정규화를 선택하는 것이
중요합니다.

# 인덱스(Index)란 무엇인가요?

인덱스(Index)는 **데이터베이스에서 검색 속도를 높이기 위한 데이터 구조**입니다. 인덱스는 **테이블 내의 하나 이상의 열(column)을 기준으로 정렬된 데이터 세트**로, 데이터를 검색할 때 이를 참조하여
빠르게 검색할
수 있습니다.

인덱스를 사용하면, 데이터베이스에서 데이터를 검색하는 데 소요되는 시간을 줄일 수 있습니다. 인덱스는 주로 WHERE 절, JOIN 절, ORDER BY 절과 같은 SQL 쿼리에서 자주 사용됩니다.

인덱스는 대개 **B-Tree, B+Tree, Hash Table 등의 알고리즘을 사용하여 구현**됩니다. 그리고, 인덱스는 데이터를 검색하는 데 필요한 **시간을 단축시키지만, 데이터베이스의 용량을 늘리고, 데이터
입력/수정/삭제에 소요되는 시간을 증가시킬 수 있습니다.** 따라서, 인덱스를 사용할 때는 적절한 대상에 대해 인덱스를 생성하고, 관리하는 것이 중요합니다.

# 트랜잭션(Transaction)이란 무엇인가요?

트랜잭션(Transaction)은 데이터베이스에서 **데이터의 무결성과 일관성을 보장하기 위한 작업 단위**를 의미합니다. 트랜잭션은 **일련의 작업을 하나의 논리적인 작업 단위로 묶어서 처리하는 것**으로, 여러
개의 쿼리나
데이터 변경 작업이 하나의 단위로 묶여 원자성을 갖습니다.

트랜잭션은 다음과 같은 특징을 가집니다.

* 원자성(Atomicity): 트랜잭션 내에서 수행되는 모든 작업은 전체가 성공하거나 전체가 실패해야 합니다. 즉, 트랜잭션이 실행되는동안 어떤 이유로든 중단될 경우, 이전 상태로 롤백(Rollback)됩니다.
* 일관성(Consistency): 트랜잭션이 수행되기 전과 후의 데이터베이스 상태가 일관성을 유지해야 합니다. 즉, 트랜잭션이 수행되기 전에 정의된 제약 조건이나 규칙이 트랜잭션 수행 후에도 만족되어야 합니다.
* 격리성(Isolation): 트랜잭션 수행 중에는 다른 트랜잭션에 의해 영향을 받지 않도록 격리되어야 합니다. 이를 통해, 다른 트랜잭션이 동시에 실행되는 경우 발생할 수 있는 문제를 방지할 수 있습니다.
* 지속성(Durability): 트랜잭션이 성공적으로 완료되면, 해당 변경 내용은 영구적으로 저장되어야 합니다.

트랜잭션은 데이터베이스에서 데이터를 안전하게 처리하기 위해 매우 중요합니다. 트랜잭션을 사용하면, 여러 개의 작업 단위가 하나의 논리적인 작업 단위로 묶여, 데이터베이스의 일관성과 무결성을 보장할 수 있습니다.

# 일관성과 무결성이란 무엇인가요?

일관성(consistency)은 데이터베이스에서 여러 개의 **데이터를 동시에 업데이트할 때, 모든 데이터가 일관된 상태를 유지하도록 보장하는 것**을 말합니다. 예를 들어, 은행에서 계좌 간 이체를 처리하는 경우,
계좌에서 출금되는 금액과 입금되는 금액이 항상 일치하도록 보장해야 합니다. **이를 위해 데이터베이스에서는 트랜잭션(Transaction)과 같은 메커니즘을 사용**합니다.

무결성(integrity)은 데이터베이스에서 **데이터의 정확성과 일관성을 보장하는 것**을 말합니다. 데이터베이스에서 저장된 데이터는 **외부의 잘못된 접근이나 의도하지 않은 변경으로부터 보호**되어야 합니다.
데이터베이스에서는
무결성 제약 조건(Integrity constraint)을 사용하여 데이터의 무결성을 보장합니다. 무결성 제약 조건은 데이터의 유효성을 검증하고, 무결성이 깨지지 않도록 강제하는 규칙입니다. 예를 들어,
**데이터베이스에서는 키(Key)와 관련된 무결성 제약 조건을 사용하여 중복된 데이터의 삽입을 방지**합니다.

따라서, 일관성과 무결성은 데이터베이스에서 데이터의 신뢰성을 보장하기 위한 중요한 개념입니다. 일관성과 무결성을 유지하면 데이터베이스에서 데이터를 안전하게 보호하고, 데이터에 대한 신뢰성을 확보할 수 있습니다.

# ORM(Object-Relational Mapping)이란 무엇인가요?

ORM(Object-Relational Mapping)은 **객체와 관계형 데이터베이스(테이블) 간의 데이터를 매핑하기 위한 기술**입니다. ORM은 객체 지향 프로그래밍에서 사용되는 객체와 관계형 데이터베이스에서
사용되는 테이블
간의 차이를 해결하기 위해, 객체와 데이터베이스 간의 매핑을 자동으로 수행합니다.

ORM을 사용하면, 데이터베이스와의 상호작용을 위한 SQL 쿼리를 직접 작성하지 않아도 됩니다. 대신, ORM 프레임워크에서 제공하는 API를 사용하여 객체를 데이터베이스에 저장하고, 검색하고, 갱신할 수 있습니다.

ORM을 사용하면, 개발자는 객체 지향적인 코드를 작성하고, 데이터베이스와의 상호작용에 대한 복잡한 부분을 ORM 프레임워크가 처리하므로, 생산성을 높일 수 있습니다. 또한, ORM을 사용하면 데이터베이스와의
상호작용이 더욱 추상화되므로, 데이터베이스를 변경해도 코드를 변경하지 않아도 됩니다.

* Hibernate: Java 언어로 작성된 ORM 프레임워크로, Java Persistence API(JPA) 표준을 구현합니다.
* Sequelize: Node.js 언어로 작성된 ORM 프레임워크로, MySQL, PostgreSQL, SQLite, MSSQL과 같은 다양한 데이터베이스와 상호작용할 수 있습니다.

# 캐싱(Caching)이란 무엇인가요?

캐싱(Caching)은 **빠른 데이터 검색을 위해 자주 사용되는 데이터를 미리 복사해 놓는 것**을 말합니다. 캐싱은 데이터의 응답 속도를 높이고, 처리 속도를 개선하기 위해 사용됩니다.

캐싱은 대개 웹 서버와 같은 애플리케이션에서 사용되며, 이를 통해 사용자의 요청에 대한 응답 속도를 높일 수 있습니다. 대표적인 예로는 웹 페이지나 API 응답 결과, 데이터베이스 쿼리 결과 등이 있습니다.

캐싱은 다음과 같은 특징을 가집니다.

* 빠른 응답 속도: 캐시된 데이터는 미리 복사해 놓기 때문에, 데이터 검색 시 원래 데이터베이스에서 검색하는 것보다 빠른 속도를 제공합니다.
* 사용자 경험 개선: 캐시를 사용하면, 사용자는 더 빠른 응답 속도와 함께 더 나은 사용자 경험을 제공받을 수 있습니다.
* 시스템 부하 감소: 캐시를 사용하면, 데이터베이스에 대한 요청 수가 줄어들기 때문에, 시스템 부하가 감소합니다.

그러나, 캐싱을 사용할 때는 데이터의 일관성과 무결성을 유지하는 것이 중요합니다. 캐시된 데이터가 원본 데이터와 다른 경우, 데이터의 무결성이 깨질 수 있으므로, **적절한 캐싱 전략을 수립**하고, 관리하는 것이
중요합니다.

# JWT(Json Web Token)란 무엇인가요?

JWT(Json Web Token)는 **인터넷에서 정보를 안전하게 전송하기 위한 인증 방식 중 하나**입니다. JWT는 **JSON 형식으로 데이터를 저장하며, 데이터의 무결성을 보장하기 위해 디지털 서명이 포함
**됩니다.

JWT는 사용자 인증 정보를 안전하게 전송하기 위해 사용됩니다. 예를 들어, 사용자가 로그인을 하면 서버에서 JWT를 발급하고, 이 JWT를 사용하여 사용자 인증 정보를 안전하게 전송할 수 있습니다. 이후 사용자가
다시 서버에 접속할 때는, JWT를 사용하여 사용자 인증을 확인할 수 있습니다.

JWT는 다음과 같은 구성 요소로 이루어져 있습니다.

* Header: JWT에 대한 메타 정보가 포함됩니다. 대표적인 예로는 알고리즘 정보 등이 있습니다.
* Payload: JWT에 저장될 정보가 포함됩니다. 대표적인 예로는 사용자 ID, 권한 정보 등이 있습니다.
* Signature: JWT의 무결성 을 보장하기 위한 디지털 서명이 포함됩니다. 서명은 Secret Key를 사용하여 생성되며, 이를 통해 JWT가 변조되지 않았는지 검증할 수 있습니다.

JWT는 **세션과 유사한 역할을 수행할 수 있지만, 세션과 달리 JWT는 서버의 메모리를 사용하지 않습니다.** 따라서, 서버 확장성이 더욱 용이하며, 사용자가 다른 서버로 이동해도 인증 정보를 유지할 수
있습니다.

# 동기(Synchronous)와 비동기(Asynchronous)의 차이점은 무엇인가요?

동기(Synchronous)와 비동기(Asynchronous)는 프로그래밍에서 두 가지 다른 처리 방식을 나타냅니다.

동기(Synchronous) 처리 방식은, **한 작업이 완료될 때까지 다른 작업을 수행하지 않는 방식**입니다. 즉, 현재 수행 중인 작업이 완료될 때까지 다음 작업으로 넘어가지 않습니다.

비동기(Asynchronous) 처리 방식은, **한 작업이 완료되지 않아도 다른 작업을 수행할 수 있는 방식**입니다. 즉, 현재 수행 중인 작업과 상관없이 다른 작업을 수행할 수 있습니다.

동기 처리 방식은 작업의 순서와 실행 시간을 보장할 수 있으므로, 코드 작성이 간단하고 이해하기 쉽습니다. 그러나, 작업이 끝날 때까지 다른 작업을 수행하지 않기 때문에, 대기 시간이 발생하거나, 작업이 느려지는
문제가 발생할 수 있습니다.

비동기 처리 방식은 작업의 순서와 실행 시간을 보장하지 않으므로, 코드 작성이 복잡하고 이해하기 어렵습니다. 그러나, 작업이 완료될 때까지 다른 작업을 수행할 수 있기 때문에, 대기 시간이나 작업이 느려지는 문제를
방지할 수 있습니다.

# 웹 서버(Web Server)와 애플리케이션 서버(Application Server)의 차이점은 무엇인가요?

웹 서버(Web Server)와 애플리케이션 서버(Application Server)는 모두 클라이언트의 요청에 대한 응답을 제공하는 서버입니다. 그러나, 두 서버 간에는 몇 가지 차이점이 있습니다.

웹 서버(Web Server)는 웹 페이지와 같은 **정적인 컨텐츠를 제공**하는 서버입니다. 대표적인 예로는 **Apache, Nginx, IIS** 등이 있습니다. 웹 서버 는 정적인 컨텐츠를 처리하기 때문에,
HTML,
CSS, JavaScript와 같은 파일을 처리하는 데 적합합니다. 또한, 웹 서버는 프로그램 실행에 필요한 환경을 제공하지 않으므로, **웹 서버 자체로는 동적인 컨텐츠를 처리할 수 없습니다.**

반면에, 애플리케이션 서버(Application Server)는 **동적인 컨텐츠를 처리하는 데 적합한 서버**입니다. 대표적인 예로는 **Tomcat**, JBoss, WebLogic, WebSphere 등이
있습니다.
애플리케이션 서버는 웹 서버와 달리, 프로그램 실행에 필요한 환경을 제공하며, 다양한 언어와 프레임워크를 지원합니다.

애플리케이션 서버는 다음과 같은 특징을 가집니다.

* 동적인 컨텐츠 처리: 애플리케이션 서버는 동적인 컨텐츠 처리에 적합하며, 다양한 언어와 프레임워크를 지원합니다.
* 분산 처리: 애플리케이션 서버는 분산 처리를 지원하므로, 서버의 확장성을 높일 수 있습니다.
* 보안 기능: 애플리케이션 서버는 보안 기능을 제공하며, 사용자 인증, 권한 부여, 데이터 암호화 등의 기능을 제공합니다.
* 트랜잭션 처리: 애플리케이션 서버는 트랜잭션 처리를 지원하므로, 데이터 일관성을 유지할 수 있습니다.

따라서, 웹 서버와 애플리케이션 서버는 각각의 역할을 가지며, 서버 환경과 업무에 따라 적절한 서버를 선택하여 사용해야 합니다.

# 그렇다면 Node.js로 만든 서버는 웹 서버인가요? 애플리케이션 서버인가요?

Node.js를 사용하여 만든 서버는 웹 서버(Web Server)와 애플리케이션 서버(Application Server) 모두의 역할을 수행할 수 있습니다.

따라서, **Node.js는 웹 서버와 애플리케이션 서버 둘 다 해당된다고 할 수 있습니다.**

# Java에서 Garbage Collection이란 무엇인가요?

Garbage Collection은 자바에서 자동 메모리 관리를 위한 기능입니다.
Garbage Collector는 JVM에서 동작하며, 더 이상 사용되지 않는 객체를 자동으로 제거합니다.
이를 통해 개발자는 메모리 관리에 대한 부담을 덜 수 있으며, 더욱 안정적인 코드를 작성할 수 있습니다.

# Java에서 오버로딩과 오버라이딩의 차이점은 무엇인가요?

오버로딩(Overloading)은 같은 이름의 메소드를 다른 매개변수를 가지도록 여러 번 정의하는 것입니다.
오버라이딩(Overriding)은 부모 클래스의 메소드를 자식 클래스에서 재정의하는 것입니다.
즉, 오버로딩은 같은 이름의 다른 메소드를 만드는 것이고, 오버라이딩은 상속받은 메소드를 다시 정의하는 것입니다.

# Java에서 인터페이스와 추상 클래스의 차이점은 무엇인가요?

추상클래스(Abstract Class)와 인터페이스(Interface)는 모두 추상화된 개념을 나타내는 기술입니다. 하지만 두 기술은 다음과 같은 차이점이 있습니다.

* 구현 방법: 추상클래스는 일반 클래스와 마찬가지로 필드, 메서드, 생성자 등을 가질 수 있으며, 추상메서드를 포함할 수 있습니다. 반면 인터페이스는 메서드와 상수 필드만을 가질 수 있으며, 모든 메서드는
  추상메서드입니다.
* 다중 상속: 추상클래스는 단일 상속만을 지원합니다. 즉, 하나의 클래스만 상속받을 수 있습니다. 반면 인터페이스는 다중 상속을 지원합니다. 즉, 여러 인터페이스를 상속받을 수 있습니다.
* 구현 강제: 추상클래스에서는 추상메서드를 선언하더라도 일반 메서드를 가질 수 있으며, 하위 클래스에서 반드시 구현할 필요가 없는 메서드를 가질 수 있습니다. 반면 인터페이스에서는 모든 메서드가 추상메서드이므로,
  하위 클래스에서 반드시 구현해야 합니다.
* 목적: 추상클래스는 하위 클래스에서 공통적인 기능을 구현하고 상속 계층을 구성하는 데 사용됩니다. 반면 인터페이스는 클래스 간의 상호작용을 위한 규약을 정의하고, 다중 상속을 지원하여 유연한 구조를 구성하는 데
  사용됩니다.
* 생성자: 추상클래스는 생성자를 가질 수 있으며, 하위 클래스에서 상위 클래스의 생성자를 호출하여 초기화할 수 있습니다. 반면 인터페이스는 생성자를 가질 수 없으며, 인터페이스를 구현한 클래스에서 직접 초기화해야
  합니다.

# Java에서 JDBC란 무엇인가요?

JDBC(Java Database Connectivity)는 자바에서 데이터베이스에 접속하기 위한 API입니다.
JDBC를 사용하면 자바에서 다양한 데이터베이스에 접속하여 데이터를 조회, 수정, 삭제할 수 있습니다.
JDBC는 데이터베이스 벤더에서 제공하는 드라이버를 사용하여 데이터베이스와 연결하며, 자바 애플리케이션과 데이터베이스 간의 통신을 담당합니다.

# Java에서 JPA(Java Persistence API)란 무엇인가요?

JPA(Java Persistence API)는 자바 언어에서 객체를 데이터베이스에 저장하고 관리할 수 있는 API입니다. JPA는 ORM(Object-Relational Mapping)을 구현하는 기술로, 객체와
데이터베이스 간의 매핑을 자동으로 처리하여 개발자가 SQL 쿼리를 직접 작성하지 않아도 됩니다.

JPA를 사용하면 객체와 데이터베이스 간의 매핑 작업을 알아서 처리해주므로, 개발자는 비즈니스 로직에 집중할 수 있습니다. 또한 JPA는 데이터베이스의 변경에 대한 처리도 자동으로 처리해주므로, 데이터베이스의
스키마를 변경할 때도 쉽게 대처할 수 있습니다.

JPA는 ORM 기술의 표준으로 Java EE 표준 스펙에 포함되어 있으며, 대표적인 구현체로는 Hibernate, EclipseLink, OpenJPA 등이 있습니다.

# 스프링 프레임워크란 무엇이며, 어떤 장점이 있나요?

스프링 프레임워크(Spring Framework)는 자바 기반의 오픈 소스 애플리케이션 프레임워크입니다. 스프링은 애플리케이션 개발에 필요한 많은 기능을 제공하며, 웹 개발, 데이터베이스 연동, 트랜잭션 처리, 보안
처리 등에 대한 다양한 모듈을 제공합니다. 스프링은 DI (의존성 주입), AOP (관점 지향 프로그래밍), POJO (Plain Old Java Object), MVC (Model-View-Controller)
등의 개념을 활용하여 객체 지향적인 개발을 지원합니다.

스프링 프레임워크의 주요 장점은 다음과 같습니다.

- 모듈성: 스프링은 각각의 모듈이 독립적으로 동작하므로, 필요한 모듈만 가져와 사용할 수 있습니다.
- 높은 확장성: 스프링은 확장성이 높기 때문에 대규모 애플리케이션에도 적용이 가능합니다.
- DI, AOP, POJO 지원: 스프링은 DI, AOP, POJO 개념을 활용하여 유지보수성이 높은 객체 지향적인 개발이 가능합니다.
- 트랜잭션 처리: 스프링은 트랜잭션 처리를 위한 기능을 제공하여 데이터베이스 연동 애플리케이션 개발을 간편하게 만듭니다.
- 보안: 스프링은 보안 처리를 위한 기능을 제공하여 애플리케이션 보안을 강화할 수 있습니다.
- 테스트 지원: 스프링은 단위 테스트와 통합 테스트를 위한 기능을 제공하여 안정적인 애플리케이션 개발을 지원합니다.

# DI (의존성 주입)란 무엇인가요?

DI(Dependency Injection, 의존성 주입)는 객체지향 프로그래밍에서 객체 간의 의존성을 외부에서 설정하도록 만드는 설계 패턴입니다. 즉, 객체가 필요로 하는 의존성 객체를 직접 생성하지 않고,
외부에서 주입받아 사용합니다.

DI 패턴은 객체 간의 결합도를 낮추고 유지보수성을 높이는데 큰 도움을 줍니다. 객체가 직접 의존하는 객체를 생성하는 것이 아니라, 외부에서 주입받아 사용하므로 객체 간의 결합도가 낮아지며, 테스트나 기능 변경
시에도 유연하게 대처할 수 있습니다.

DI 패턴은 대표적으로 세 가지 방법으로 구현됩니다.

* 생성자 주입(Constructor Injection): 의존성 객체를 객체 생성자의 인자로 전달받습니다.
* 필드 주입(Field Injection): 의존성 객체를 인스턴스 변수로 직접 선언하고, 어노테이션을 이용하여 주입합니다.
* 메서드 주입(Method Injection): 의존성 객체를 인스턴스 메서드의 인자로 전달받습니다.

# AOP (관점 지향 프로그래밍)란 무엇인가요?

AOP(Aspect-Oriented Programming, 관점 지향 프로그래밍)은 객체지향 프로그래밍의 한 종류로, 코드의 횡단 관심사(Cross-Cutting Concerns)를 모듈화하고 분리하여 재사용성과
유지보수성을 높이는 기술입니다. 코드의 횡단 관심사란, 여러 모듈에서 공통적으로 발생하는 문제로, 예를 들어 로깅, 예외 처리, 트랜잭션 관리 등이 있습니다.

AOP는 횡단 관심사를 별도의 모듈로 분리하고, 이를 주요 비즈니스 로직 모듈과 결합하여 사용합니다. 이를 위해 AOP는 주요 비즈니스 로직 모듈과 횡단 관심사 모듈을 각각 Aspect(관점)이라는 단위로 분리하고,
이를 조합하여 하나의 애플리케이션을 구성합니다. AOP를 이용하면 관심사 모듈을 변경하더라도 주요 비즈니스 로직 모듈에 영향을 주지 않으므로, 유지보수성이 높아집니다.

# 스프링 프레임워크에서 POJO는 무엇인가요?

스프링 프레임워크에서 POJO(Plain Old Java Object)는 스프링의 핵심 개념 중 하나입니다. 스프링은 POJO를 기반으로 한 IoC(Inversion of Control)와 DI(Dependency
Injection)를 지원하여, 애플리케이션을 개발하는 데 큰 도움을 줍니다.

스프링에서 POJO는 인터페이스를 구현하거나, 특정한 클래스를 상속받지 않은 순수한 자바 객체를 뜻합니다. 이러한 POJO를 이용하여 스프링에서는 객체간의 의존성을 줄이고, 느슨한 결합(Loose Coupling)을
구현하여 유지보수성과 확장성을 높일 수 있습니다.

스프링에서 POJO는 다음과 같은 특징을 가집니다.

* 인터페이스나 추상 클래스를 상속받지 않음
* 특정한 라이브러리나 프레임워크에 의존하지 않음
* 일반적인 자바 객체로, 단순하고 가독성이 좋음
* 유연하고 재사용성이 높음
* 객체지향 프로그래밍의 기본 원칙을 따름

스프링에서는 POJO를 이용하여 IoC(Inversion of Control)와 DI(Dependency Injection)를 구현합니다. 이를 통해 애플리케이션 개발 시 객체 간의 의존성을 설정하고, 관리할 수
있으며, 테스트 용이성이 향상됩니다. 스프링의 DI 기능을 이용하면, 객체 생성 및 의존성 주입을 자동으로 처리할 수 있습니다. 따라서 개발자는 비즈니스 로직에 집중하여 애플리케이션을 빠르게 개발할 수 있습니다.